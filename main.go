package main

import (
	"fmt"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"golang.org/x/exp/slices"
	"golang.org/x/sys/unix"
)

type ExitCode int

const (
	EX_USAGE     = ExitCode(64)
	EX_OSERR     = ExitCode(71)
	EX_OSFILE    = ExitCode(72)
	EX_CANTCREAT = ExitCode(73)
	EX_IOERR     = ExitCode(74)
)

const HELP = `usage: mj OPTIONS|COMPILATION...

mj injects Clang compiler options to generate a compilation database.
If no options are provided, the arguments to mj should be a full Clang
commandline. mj will inject the '-MJ' option and run the Clang command.

Options:
  --collate  This option finds all the compilation database fragments
             generated by Clang, and collates them into a single file
             named "compile_commands.json".
  --help, --usage 
             Show this help message.
`

func fatalf(e ExitCode, format string, args ...any) {
	fmt.Fprintf(os.Stderr, "mj: %s\n", fmt.Sprintf(format, args...))
	os.Exit(int(e)) // sysexits
}

func collate() {
	compdb, err := os.Create("compile_commands.json")
	if err != nil {
		fatalf(EX_CANTCREAT, err.Error())
	}

	compdb.Write([]byte("[\n")) //nolint:errcheck

	err = filepath.Walk(".", func(path string, info fs.FileInfo, err error) error {
		// If there's a traversal error, just keep going.
		if err != nil {
			return nil
		}

		// Ignore files that aren't compilation DB fragments.
		if !strings.HasSuffix(path, ".db.json") {
			return nil
		}

		content, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		_, err = compdb.Write(content)
		return err
	})

	if err != nil {
		compdb.Close()                     //nolint:errcheck
		os.Remove("compile_commands.json") //nolint:errcheck

		fatalf(EX_IOERR, err.Error())
	}

	// Each fragment ends with a comma, so write an empty record to make
	// the compilation database valid JSON.
	compdb.Write([]byte(`{"file":"","directory":"","arguments":[]}\n`)) //nolint:errcheck
	compdb.Write([]byte("}\n]"))                                        //nolint:errcheck

	compdb.Sync()  //nolint:errcheck
	compdb.Close() //nolint:errcheck
}

func compile(argv ...string) {
	// Scan for the output option. We only want to inject the "-MJ" if
	// this compilation job is building some source to an object file.
	// This doesn't capture all the cases where it might be useful
	// to generate a compilation database (e.g. compiling a source
	// file directly to an executable), but it is enough to work with
	// automake and similar builds.
	for i, arg := range argv {
		if arg != "-o" {
			continue
		}

		if (i + 1) < len(argv) {
			objectPath := argv[i+1]

			if strings.HasSuffix(objectPath, ".o") {
				argv = slices.Insert(argv, 1,
					"-MJ", strings.TrimSuffix(objectPath, ".o")+".db.json",
				)
			}

			break
		}
	}

	compilerPath, err := exec.LookPath(argv[0])
	if err != nil {
		fatalf(EX_OSFILE, err.Error())
	}

	if err = unix.Exec(compilerPath, argv, os.Environ()); err != nil {
		fatalf(EX_OSERR, err.Error())
	}
}

func main() {
	switch len(os.Args) {
	case 0, 1:
		fmt.Fprint(os.Stderr, HELP)
		os.Exit(int(EX_USAGE))
	case 2:
		switch os.Args[1] {
		case "--collate":
			collate()
		default:
			fmt.Fprint(os.Stderr, HELP)
			os.Exit(int(EX_USAGE))
		}
	default:
		if os.Args[1] == "--" {
			compile(os.Args[2:]...)
		} else if strings.HasPrefix(os.Args[1], "-") {
			fmt.Fprint(os.Stderr, HELP)
			os.Exit(int(EX_USAGE))
		} else {
			compile(os.Args[1:]...)
		}
	}
}
